# -*- coding: utf-8 -*-
"""modelo_covid.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tT3lyV101R6Nf3r0UnlbpAZULuXlCnmg
"""

#Projeto COVID-19 (DIO)
import pandas as pd
import numpy as np
from datetime import datetime
import plotly.express as px
import plotly.graph_objects as go

#Importar dados do projeto
#url = 'https://github.com/neylsoncrepalde/projeto_eda_covid/blob/master/covid_19_data.csv?raw=true'
#df = pd.read_csv(url, parse_dates=['ObservationDate', 'Last Update'])
df = pd.read_csv("/content/drive/MyDrive/covid_19_data.csv", parse_dates=['ObservationDate', 'Last Update'])

df.head(3)

#conferir os tipos de cada coluna
df.dtypes

#nomes de colunas nao devem ter letras maiusculas ou caracteres especiais. implementar limpeza
import re

def corrige_colunas(column_name):
  return re.sub(r"[/| ]", "", column_name).lower()

#teste
corrige_colunas("AdgE/P ou")

#corrige colunas do df
df.columns = [corrige_colunas(col) for col in df.columns]

df.head(3)

df.countryregion.value_counts().head(10)

df.countryregion.unique()

#selecionar apenas os dados do Brasil
brasil = df.loc[(df.countryregion == 'Brazil') & (df.confirmed > 0)]

brasil.head(3)

#grafico da evolução de casos confirmados
px.line(brasil, x='observationdate', y='confirmed', labels={'observationdate':'Data', 'confirmed':'Número de casos confirmados'}, title='Casos Confirmados no Brasil')

brasil.shape

#novos casos por dia (tecnica de programação funcional)
#map: pega uma função, e aplica em todos os casos, retornando um interador
brasil['novoscasos'] = list(map( #primeiro caso: 0; demais, substração entre os dias atual e anterior
    lambda x: 0 if(x == 0) else brasil['confirmed'].iloc[x] - brasil['confirmed'].iloc[x-1],
    np.arange(brasil.shape[0])
))

brasil.tail(3)

#grafico da evolução de novos casos
px.line(brasil, x='observationdate', y='novoscasos', title='Novos casos por dia', labels={'observationdate': 'Data', 'novoscasos': 'Novos casos'})

fig = go.Figure() #defini a figura
fig.add_trace( #trace: camada de dados
    go.Scatter(x=brasil.observationdate, y=brasil.deaths, name='Mortes', mode='lines+markers', line={'color':'red'})
)
#layout
fig.update_layout(title='Mortes por COVID-19 no Brasil')
fig.show()

#taxa de crescimento (no minimo um caso): taxa_crescimento = (presente/passado)**(1/n) -1
def taxa_crescimento(data, variavel, data_inicio=None, data_fim=None):
  #se data_inicio for "None", define como a primeira data disponível no dataset
  if data_inicio == None:
    data_inicio = data.observationdate.loc[data[variavel] > 0].min()
  else:
    data_inicio = pd.to_datetime(data_inicio)
  
  if data_fim == None:
    data_fim = data.observationdate.iloc[-1] #-1: ultimo caso
  else:
    data_fim = pd.to_datetime(data_fim)
  #define os valores de presente e passado
  passado = data.loc[data.observationdate == data_inicio, variavel].values[0]
  presente = data.loc[data.observationdate == data_fim, variavel].values[0]
  #define o número de pontos no tempo q vamos avaliar
  n = (data_fim - data_inicio).days
  #calcula a taxa
  taxa = (presente/passado)**(1/n) -1
  return taxa*100

#taxa de crescimento médio do COVID no Brasil em todo o periodo
taxa_crescimento(brasil, 'confirmed')

def taxa_crescimento_diaria(data, variavel, data_inicio=None):
  #se data_inicio for "None", define como a primeira data disponível
  if data_inicio == None:
    data_inicio = data.observationdate.loc[data[variavel] > 0].min()
  else:
    data_inicio = pd.to_datetime(data_inicio)
  
  data_fim = data.observationdate.max() #necessariamente a ultima data
  #define o número de pontos no tempo q vamos avaliar
  n = (data_fim - data_inicio).days
  #taxa calcula de um dia para outro
  taxas = list(map(
      lambda x: (data[variavel].iloc[x] - data[variavel].iloc[x-1] / data[variavel].iloc[x-1]), #hoje-ontem/ontem
      range(1, n+1) #do segundo ate o ultimo
  ))
  return np.array(taxas)*100

taxa_dia = taxa_crescimento_diaria(brasil, 'confirmed')

taxa_dia[-6:-1]

#crescimento inicial é maior (diferenca entre os valores!)
primeiro_dia = brasil.observationdate.loc[brasil.confirmed > 0].min()
px.line(x=pd.date_range(primeiro_dia, brasil.observationdate.max())[1:],
        y=taxa_dia, title='Taxa de crescimento de casos confirmados no Brasil')

#predições
from statsmodels.tsa.seasonal import seasonal_decompose
import matplotlib.pyplot as plt

confirmados = brasil.confirmed
confirmados.index = brasil.observationdate
confirmados

#Erro nesse trecho do código
"""res = seasonal_decompose(confirmados)

fig, (ax1, ax2, ax3, ax4) = plt.subplots(4, 1, figsize=(10,8)) #4 graficos/eixos em uma figura
ax1.plot(res.observed) #observados
ax2.plot(res.trend) #tendencia
ax3.plot(res.seasonal) #sazonalidade
ax4.plot(confirmados.index, res.resid) #ruido
ax4.axhline(0, linestyle='dashed', c='black')
plt.show()"""

#Arima (tenta modelar o futuro em funcao do passado)
!pip install pmdarima

#Erro nesse trecho do código
"""from pmdarima.arima import auto_arima
modelo = auto_arima(confirmados)"""

pd.date_range('2020-05-01', '2020-05-19')

#Erro devido a variavel modelo
"""fig = go.Figure(go.Scatter(
    x=confirmados.index, y=confirmados, name='Observados'
))

fig.add_trace(go.Scatter(
    x=confirmados.index, y = modelo.predict_in_sample(), name='Preditos'
))

fig.add_trace(go.Scatter(
    x=pd.date_range('2020-05-20', '2020-06-20'), y=modelo.predict(31), name='Forecast'
))

fig.update_layout(title='Previsão de casos confirmados no Brasil', yaxis_title='Casos confirmados', xaxis_title='Data')
fig.show()"""

#Modelo de crescimento (prever o ponto de virada, quando a curva ira achatar)
!pip install fbprophet
!pip install yfinance

import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import datetime as datetime
from fbprophet import Prophet

#Preprocessamentos (delimitar o ponto de corte, parte para o treino, e outra parte para teste)
train = confirmados.reset_index()[:-5]
test = confirmados.reset_index()[-5:]

#Renomeia colunas (exigencia)
train.rename(columns={"observationdate":"ds","confirmed":"y"},inplace=True)
test.rename(columns={"observationdate":"ds","confirmed":"y"},inplace=True)

#Definir o modelo de crescimento (grafico de curva de contagio: forma sigmoide)
profeta = Prophet(growth="logistic", changepoints=['2020-03-21', '2020-03-30', '2020-04-25', 
                                                   '2020-05-03', '2020-05-10'])

#Projecao da populacao brasileira (2 cenarios de pop)
#pop = 211463256 #https://www.ibge.gov.br/apps/populacao/projecao/box_popclock.php
pop = 1000000
train['cap'] = pop

#Treina o modelo
profeta.fit(train)

#Construir previsoes para o futuro
future_dates = profeta.make_future_dataframe(periods=200)
future_dates['cap'] = pop
forecast =  profeta.predict(future_dates)

fig = go.Figure()

fig.add_trace(go.Scatter(x=forecast.ds, y=forecast.yhat, name='Predição'))
#fig.add_trace(go.Scatter(x=test.index, y=test, name='Observados - Teste'))
fig.add_trace(go.Scatter(x=train.ds, y=train.y, name='Observados - Treino'))
fig.update_layout(title='Predições de casos confirmados no Brasil')
fig.show()